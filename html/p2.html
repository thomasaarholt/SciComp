
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>p2</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-11-15"><meta name="DC.source" content="p2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Problem 2</a></li><li><a href="#17">Problem 3</a></li><li><a href="#18">Problem 4</a></li><li><a href="#19">Build a discrete 2D Laplace operator</a></li><li><a href="#21">PART 2</a></li><li><a href="#24">Problem 5</a></li></ul></div><h2>Problem 2<a name="1"></a></h2><p>I create a 0-1 matrix with 50 columns, turn it into a vandermonde matrix where all the values previously in the columns 1-50 now are in column 2, rows 1-50, with the rest of the columns formatted according to the vandermonde matrix.</p><pre class="codeinput">m = 50
n = 5
</pre><pre class="codeoutput">
m =

    50


n =

     5

</pre><p>Creating t, the 0-1 vector with m spaces.</p><pre class="codeinput">t = linspace(0,1,m)';
</pre><p>Creating a vandermonde matrix (the right way around with fliplr)</p><pre class="codeinput">A = fliplr(vander(t));
</pre><p>Removing the entries after the fifth row - we don't want the higher powers)</p><pre class="codeinput">n2 = n + 1
A(:,n2:end)=[];
b = cos(4*t);
</pre><pre class="codeoutput">
n2 =

     6

</pre><p>What does cos(4t) look like?</p><pre class="codeinput">COS = plot(t,b,<span class="string">'r-.'</span>);
set(COS,<span class="string">'LineWidth'</span>,15);

hold <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="p2_01.png" alt=""> <p>Solving by Matlab's backslash command</p><pre class="codeinput">xx(:,1) = A\b;

BACKS = plot(t,A*xx(:,1),<span class="string">'b'</span>);
set(BACKS,<span class="string">'LineWidth'</span>,9);
</pre><img vspace="5" hspace="5" src="p2_02.png" alt=""> <p>Finding the normal equations by multiplying with the transpose of A on both sides -&gt; A^T * A * x = A^T * b. Rearranging:</p><pre class="codeinput">xx(:,2) = (A'*A)\(A'*b);
</pre><p>Plotting the normal equations solution:</p><pre class="codeinput">NORMAL = plot(t,A*xx(:,2),<span class="string">'g'</span>);
set(NORMAL,<span class="string">'LineWidth'</span>,6);
</pre><img vspace="5" hspace="5" src="p2_03.png" alt=""> <p>Finding the solution by QR factorisation:</p><pre class="codeinput">[Q,R] = qr(A);
xx(:,3) = R\Q'*b;
</pre><p>Plotting the qr solution:</p><pre class="codeinput">QR = plot(t,A*xx(:,3),<span class="string">'y'</span>)
set(QR,<span class="string">'LineWidth'</span>,3)
</pre><pre class="codeoutput">
QR =

     1.820924072265625e+02

</pre><img vspace="5" hspace="5" src="p2_04.png" alt=""> <p>Finding the solution by svd:</p><pre class="codeinput">[U,S,V] = svd(A,0);
</pre><p>Simplifying for later:</p><pre class="codeinput">G = U * S * V';
</pre><p>Solving for svd</p><pre class="codeinput">xx(:,4) = (G'*G)\(G'*b);
</pre><p>Plotting the svd solution, adding pretty things:</p><pre class="codeinput">SVD = plot(t,A*xx(:,4),<span class="string">'black'</span>);
set(SVD,<span class="string">'LineWidth'</span>,2)
legend(<span class="string">'COS'</span>,<span class="string">'BACKSLASH'</span>,<span class="string">'NORMAL'</span>,<span class="string">'QR'</span>,<span class="string">'SVD'</span>)
title(<span class="string">'Solving y = cos(4t) in different ways'</span>)
xlabel(<span class="string">'radians'</span>);
ylabel(<span class="string">'function solution'</span>)
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="p2_05.png" alt=""> <p>Solutions of x:</p><pre class="codeinput">xx
</pre><pre class="codeoutput">
xx =

  Columns 1 through 3

   0.977651051050956   0.977651051050360   0.977651051050948
   0.787296437030590   0.787296437042173   0.787296437030584
 -13.726690028111138 -13.726690028160782 -13.726690028111079
  14.993014653596203  14.993014653670262  14.993014653596113
  -3.665759654743957  -3.665759654779711  -3.665759654743917

  Column 4

   0.977651051050924
   0.787296437030878
 -13.726690028111268
  14.993014653595205
  -3.665759654743045

</pre><p>Norms:</p><pre class="codeinput"><span class="keyword">for</span> c = 1:4
    norm(A*xx(:,c)-b,2)
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans =

   0.061356756239887


ans =

   0.061356756239888


ans =

   0.061356756239887


ans =

   0.061356756239888

</pre><h2>Problem 3<a name="17"></a></h2><pre class="codeinput"><span class="keyword">for</span> c = 1:4

Error(c) = cond(A*xx(:,c));

<span class="keyword">end</span>
</pre><h2>Problem 4<a name="18"></a></h2><pre class="codeinput">clear <span class="string">all</span>
<span class="comment">% PART 1</span>

type(<span class="string">'readimg.m'</span>)
[u] = readimg(<span class="string">'testpat_blur2.png'</span>);
</pre><pre class="codeoutput">
%% Code reads a square greyscale image, passes it to u

function [u] = readimg(imgstring)
u = imread(imgstring);
u = double(u) / 255;

[n,n2] = size(u);
if (n ~= n2)
  error('by default, this only supports square images')
end
end
</pre><h2>Build a discrete 2D Laplace operator<a name="19"></a></h2><pre class="codeinput">type(<span class="string">'unsharpen.m'</span>)

unsharp = unsharpen(u,10); <span class="comment">% Apply image unsharp mask</span>

figure(1); clf; <span class="comment">% Clears figure for new images</span>

subplot(1,2,1), imagesc(u);
type(<span class="string">'greyimg.m'</span>)
greyimg();

subplot(1,2,2), imagesc(unsharp);
greyimg();
</pre><pre class="codeoutput">
%% Code creates a blurry mask, subtracts it from image u 
% to find the difference, then adds the 
% difference to the image in order to sharpen it.

function [unsharp] = unsharpen(u,iterations)

[n,n2] = size(u);

e = ones(n,1);
L1 = spdiags([e  -2*e  e], [-1 0 1], n, n);

L1(1,1) = -1;   
L1(end,end) = -1;

I = speye(n,n);
L = kron(L1, I) + kron(I, L1);

v = reshape(u, n*n, 1);

for i=1:iterations
  v = v + 0.01*(L*v);
end

ublur = reshape(v, n, n);
%%
% This changes a blurring function to a unsharp mask.
edgemap = u - ublur;
unsharp = u + edgemap;

end

%% Code formats images the way I want them

function [] = greyimg()
caxis([0 1])
colormap(gray)
axis equal, axis tight
end
</pre><img vspace="5" hspace="5" src="p2_06.png" alt=""> <p>Image becomes blurred!</p><h2>PART 2<a name="21"></a></h2><pre class="codeinput">[u] = readimg(<span class="string">'testpat_noblur.png'</span>); <span class="comment">% Read image from file</span>

unsharp = unsharpen(u,10); <span class="comment">% Apply image unsharp mask</span>

figure(1); clf; <span class="comment">% Clears figure for new images</span>
</pre><img vspace="5" hspace="5" src="p2_07.png" alt=""> <p>Plots full size and zoomed versions of original image, 10 step blurring and 100 step blurring.</p><pre class="codeinput">subplot(3,2,1), imagesc(u);
greyimg();
title(<span class="string">'Original "testpat noblur.png"'</span>)

subplot(3,2,2), imagesc(u);
greyimg();
axis([30 60 30 60])
title(<span class="string">'Zoomed original'</span>)


subplot(3,2,3), imagesc(unsharp);
greyimg();
title(<span class="string">'Unsharpened image"'</span>)


subplot(3,2,4), imagesc(unsharp);
greyimg();
axis([30 60 30 60])
title(<span class="string">'Unsharpened zoomed at edge, 10 blurring steps'</span>)

unsharp100 = unsharpen(u,100);

subplot(3,2,5), imagesc(unsharp100);
greyimg();
title(<span class="string">'Unsharpened image"'</span>)

subplot(3,2,6), imagesc(unsharp100);
greyimg();
axis([30 60 30 60])
title(<span class="string">'Unsharpened zoomed at edge, 100 blurring steps'</span>)

hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="p2_08.png" alt=""> <p>The sharpening of the image enhances the contrast between points that are already contrasting. For a unblurred image, this ramps up the "whiteness" of the image to the point of making it "grainy", as can be seen on the zoomed plot of the 100 stepped blurring image.</p><h2>Problem 5<a name="24"></a></h2><p>What is the data we want to fit against?</p><pre class="codeinput">xx = [3,1,0,-1,-2,0,-2,2]'
yy = [3,-2,3,2,-2,-4,0,0]'
<span class="comment">% Having a look:</span>
figure(2);
scatter(xx,yy,100,<span class="string">'r'</span>,<span class="string">'filled'</span>)
axis([-6,6,-6,6])
hold <span class="string">on</span>

type(<span class="string">'ellipse.m'</span>)

[b,c,d] = ellipse(xx,yy);

grid <span class="string">on</span>

[b,c,d] = ellipse(xx,yy);

ellipseplot(b,c,d);
</pre><pre class="codeoutput">
xx =

     3
     1
     0
    -1
    -2
     0
    -2
     2


yy =

     3
    -2
     3
     2
    -2
    -4
     0
     0


function [b,c,d] = ellipse(x,y)
    
    format long
   
    A(:,1) = x.^2;
    A(:,2) = x.*y;
    A(:,3) = y.^2;

    B = ones(length(x),1);
    
    
    X = A\B
    b = X(1)
    c = X(2)
    d = X(3)
end


X =

   0.257358001450461
  -0.200536979030043
   0.075581341521749


b =

   0.257358001450461


c =

  -0.200536979030043


d =

   0.075581341521749


X =

   0.257358001450461
  -0.200536979030043
   0.075581341521749


b =

   0.257358001450461


c =

  -0.200536979030043


d =

   0.075581341521749


ac =

   1.820287367198024


bc =

   5.666950483095532

</pre><img vspace="5" hspace="5" src="p2_09.png" alt=""> <pre class="codeinput">figure(3);

axis([-3 3 -3 3]), axis <span class="string">manual</span>, hold <span class="string">on</span>, grid <span class="string">on</span>
x = []; y = []; button = 1;
disp(<span class="string">'input points with mouse, button &gt;= 2 for final point'</span>)
<span class="keyword">while</span> button == 1
[xx,yy,button] = ginput(1)
x = [x; xx]; y = [y; yy]; plot(xx,yy,<span class="string">'x'</span>)
<span class="keyword">end</span>

[b,c,d] = ellipse(x,y)
ellipseplot(b,c,d);

clear <span class="string">all</span>
</pre><pre class="codeoutput">input points with mouse, button &gt;= 2 for final point

xx =

  -0.380184331797235


yy =

   1.605263157894737


button =

     1


xx =

  -1.472350230414746


yy =

   0.114035087719298


button =

     1


xx =

  -0.504608294930875


yy =

  -1.429824561403509


button =

     1


xx =

   0.656682027649770


yy =

  -0.622807017543860


button =

     1


xx =

   0.559907834101383


yy =

   1.096491228070176


button =

     3


X =

   0.529427425163086
   0.049320791529590
   0.436935458563534


b =

   0.529427425163086


c =

   0.049320791529590


d =

   0.436935458563534


b =

   0.529427425163086


c =

   0.049320791529590


d =

   0.436935458563534


ac =

   1.366416557677757


bc =

   1.523619893793862

</pre><img vspace="5" hspace="5" src="p2_10.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Problem 2
% I create a 0-1 matrix with 50 columns, turn it into a vandermonde matrix
% where all the values previously in the columns 1-50 now are in column 2,
% rows 1-50, with the rest of the columns formatted according to the
% vandermonde matrix.
m = 50
n = 5

%%
% Creating t, the 0-1 vector with m spaces.
t = linspace(0,1,m)';

%%
% Creating a vandermonde matrix (the right way around with fliplr)
A = fliplr(vander(t));

%%
% Removing the entries after the fifth row - we don't want the higher
% powers)
n2 = n + 1
A(:,n2:end)=[];
b = cos(4*t);

%% 
% What does cos(4t) look like?

COS = plot(t,b,'r-.');
set(COS,'LineWidth',15);

hold on

%%
% Solving by Matlab's backslash command
xx(:,1) = A\b;

BACKS = plot(t,A*xx(:,1),'b');
set(BACKS,'LineWidth',9);

%%
% Finding the normal equations by multiplying with the transpose of A on
% both sides -> A^T * A * x = A^T * b. Rearranging:

xx(:,2) = (A'*A)\(A'*b);
%%
% Plotting the normal equations solution:
NORMAL = plot(t,A*xx(:,2),'g');
set(NORMAL,'LineWidth',6);

%% 
% Finding the solution by QR factorisation: 
[Q,R] = qr(A);
xx(:,3) = R\Q'*b;

%%
% Plotting the qr solution:

QR = plot(t,A*xx(:,3),'y')
set(QR,'LineWidth',3)

%% 
% Finding the solution by svd:
[U,S,V] = svd(A,0);
%%
% Simplifying for later:
G = U * S * V';
%%
% Solving for svd
xx(:,4) = (G'*G)\(G'*b);

%%
% Plotting the svd solution, adding pretty things:
SVD = plot(t,A*xx(:,4),'black');
set(SVD,'LineWidth',2)
legend('COS','BACKSLASH','NORMAL','QR','SVD')
title('Solving y = cos(4t) in different ways')
xlabel('radians');
ylabel('function solution')
hold off

%% 
% Solutions of x:
xx
%%
% Norms:
for c = 1:4
    norm(A*xx(:,c)-b,2)
end

%% Problem 3
% 
for c = 1:4
        
Error(c) = cond(A*xx(:,c));

end

%% Problem 4

clear all
% PART 1

type('readimg.m')
[u] = readimg('testpat_blur2.png');
%% Build a discrete 2D Laplace operator
type('unsharpen.m')

unsharp = unsharpen(u,10); % Apply image unsharp mask

figure(1); clf; % Clears figure for new images

subplot(1,2,1), imagesc(u);
type('greyimg.m')
greyimg();

subplot(1,2,2), imagesc(unsharp);
greyimg();

%%
% Image becomes blurred!

%% PART 2

[u] = readimg('testpat_noblur.png'); % Read image from file

unsharp = unsharpen(u,10); % Apply image unsharp mask

figure(1); clf; % Clears figure for new images

%%
% Plots full size and zoomed versions of original image, 10 step blurring
% and 100 step blurring.
subplot(3,2,1), imagesc(u);
greyimg();
title('Original "testpat noblur.png"')

subplot(3,2,2), imagesc(u);
greyimg();
axis([30 60 30 60])
title('Zoomed original')


subplot(3,2,3), imagesc(unsharp);
greyimg();
title('Unsharpened image"')


subplot(3,2,4), imagesc(unsharp);
greyimg();
axis([30 60 30 60])
title('Unsharpened zoomed at edge, 10 blurring steps')

unsharp100 = unsharpen(u,100);

subplot(3,2,5), imagesc(unsharp100);
greyimg();
title('Unsharpened image"')

subplot(3,2,6), imagesc(unsharp100);
greyimg();
axis([30 60 30 60])
title('Unsharpened zoomed at edge, 100 blurring steps')

hold off

%%
% The sharpening of the image enhances the contrast between points that are
% already contrasting. For a unblurred image, this ramps up the "whiteness"
% of the image to the point of making it "grainy", as can be seen on the
% zoomed plot of the 100 stepped blurring image.

%% Problem 5
% What is the data we want to fit against?
xx = [3,1,0,-1,-2,0,-2,2]'
yy = [3,-2,3,2,-2,-4,0,0]'
% Having a look:
figure(2);
scatter(xx,yy,100,'r','filled')
axis([-6,6,-6,6])
hold on

type('ellipse.m')

[b,c,d] = ellipse(xx,yy);

grid on

[b,c,d] = ellipse(xx,yy);

ellipseplot(b,c,d);
%%

figure(3);

axis([-3 3 -3 3]), axis manual, hold on, grid on
x = []; y = []; button = 1;
disp('input points with mouse, button >= 2 for final point')
while button == 1
[xx,yy,button] = ginput(1)
x = [x; xx]; y = [y; yy]; plot(xx,yy,'x')
end

[b,c,d] = ellipse(x,y)
ellipseplot(b,c,d);

clear all

##### SOURCE END #####
--></body></html>